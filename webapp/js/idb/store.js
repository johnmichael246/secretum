// Copyright 2016-2017 Danylo Vashchilenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const co = require('../utils/co.js');

module.exports = class Store {
  constructor(db) {
    this.db = db;
  }
  
  findSecrets(query) {
    const self = this;
    return co(function*() {
      const match = (secret) => {
        if (query === undefined) return true;
        
        if (query.group !== undefined && secret.groupId !== query.group) {
          return false;
        }
        
        if (query.keyword !== undefined) {
          query.keyword = query.keyword.toLowerCase();
          if (secret.resource.toLowerCase().search(query.keyword) == -1
            && secret.principal.toLowerCase().search(query.keyword) == -1
            && secret.note.toLowerCase().search(query.keyword) == -1) {
            return false;
          }
        }
        return true;
      };
      
      const tx = self.db.transaction(['secrets', 'groups']);
      
      const secrets = yield tx.objectStore('secrets').toArray();
      const groups = yield tx.objectStore('groups').toMap();
      for(let secret of secrets) {
        secret.groupName = groups.get(secret.groupId).name;
      }
      
      return secrets.filter(match);
    });
  }
  
  getSecret(id) {
    return Promise.resolve(this.db.transaction('secrets').objectStore('secrets').get(id));
  }
  
  saveSecret(newSecret) {
    return Promise.resolve(this.db.transaction('secrets', 'readwrite').objectStore('secrets').put(newSecret));
  }
  
  createSecret(secret) {
    // Will be auto-generated by IDB
    delete secret.id;
    
    return Promise.resolve(this.db.transaction('secrets', 'readwrite').objectStore('secrets').add(secret));
  }
  
  removeSecret(id) {
    return Promise.resolve(this.db.transaction('secrets', 'readwrite').objectStore('secrets').delete(id));
  }
  
  findGroups() {
    return Promise.resolve(this.db.transaction('groups').objectStore('groups').toArray());
  }
  
  getGroup(id) {
    return Promise.resolve(this.db.transaction('groups').objectStore('groups').get(id));
  }
  
  createGroup(group) {
    // Will be auto-generated by IDB
    delete group.id;
    
    return Promise.resolve(this.db.transaction('groups', 'readwrite').objectStore('groups').add(group));
  }
  
  saveGroup(group) {
    return Promise.resolve(this.db.transaction('groups', 'readwrite').objectStore('groups').put(group));
  }
  
  removeGroup(id) {
    return Promise.resolve(this.db.transaction('groups', 'readwrite').objectStore('groups').delete(id));
  }
};