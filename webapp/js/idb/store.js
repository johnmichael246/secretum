// Copyright 2016-2017 Danylo Vashchilenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const SyncThenable = require('./sync-thenable.js');
const co = require('../utils/co.js');

class Store {
  constructor(db) {
    this.db = db;
  }
  
  findGroups() {
    return Promise.resolve(this.db.transaction('groups').objectStore('groups').toArray());
  }
  
  findSecrets(query) {
    const self = this;
    return co(function*() {
      const match = (secret) => {
        if (query === undefined) return true;
        
        if (query.group !== undefined && secret.groupId !== query.group) {
          return false;
        }
        
        if (query.keyword !== undefined) {
          query.keyword = query.keyword.toLowerCase();
          if (secret.resource.toLowerCase().search(query.keyword) == -1
            && secret.principal.toLowerCase().search(query.keyword) == -1
            && secret.note.toLowerCase().search(query.keyword) == -1) {
            return false;
          }
        }
        return true;
      };
      
      const secrets = yield self.db.transaction('secrets').objectStore('secrets').toArray();
      return secrets.filter(match);
    });
  }
  
  saveSecret(newSecret) {
    return Promise.resolve(this.db.transaction('secrets', 'readwrite').objectStore('secrets').put(newSecret));
  }
  
  createSecret(secret) {
    // Will be auto-generated by IDB
    delete secret.id;
    
    return Promise.resolve(this.db.transaction('secrets', 'readwrite').objectStore('secrets').add(secret));
  }
  
  removeSecret(id) {
    return Promise.resolve(this.db.transaction('secrets', 'readwrite').objectStore('secrets').delete(id));
  }
  
  getSecret(id) {
    return Promise.resolve(this.db.transaction('secrets').objectStore('secrets').get(id));
  }
  
  getGroup(id) {
    return Promise.resolve(this.db.transaction('groups').objectStore('groups').get(id));
  }
  
  
  // _transaction(stores, {mode = 'readonly', strategy = 'require'}={}) {
  //   if (this._tx && strategy !== 'new') {
  //     if (!stores.every(store => this._tx.stores.includes(store))) {
  //       throw new Error(`Attempted transaction (scope: ${stores}), while a narrower scope (${this._tx.stores}) is active.`);
  //     }
  //     if (mode === 'readwrite' && this._tx.mode != 'readwrite') {
  //       throw new Error('Attempted overlapping transaction with a more restrictive mode');
  //     }
  //     return this._tx.tx;
  //   } else {
  //     const tx = this.config.db.transaction(stores, mode);
  //     tx.onabort = tx.onerror = (error) => {
  //       console.error('Transaction failed', error);
  //       this._tx = undefined
  //     };
  //
  //     tx.oncomplete = () => {
  //       console.log('Transaction completed.');
  //       this._tx = undefined
  //     };
  //
  //     this._tx = {tx: tx, stores: stores, mode: mode};
  //     return tx;
  //   }
  // }
}

module.exports = Store;