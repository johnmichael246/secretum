// Copyright 2016-2017 Danylo Vashchilenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { SyncThenable } from './sync-thenable.js';

export function load(config) {
		return new Promise((resolve, reject) => {
			var openRequest = window.indexedDB.open(config.idb_name, 1);
			openRequest.onsuccess = () => {
				const db = openRequest.result;
				db.onerror = console.error;

				resolve(db);

				console.log('IndexedDB is now open.');
			};
			openRequest.onerror = reject;
			openRequest.onupgradeneeded = () => {
				const db = openRequest.result;
        db.onerror = console.error;

				db.createObjectStore('secrets', {keyPath: 'id', autoIncrement: true});
				const groups = db.createObjectStore('groups', {keyPath: 'id', autoIncrement: true});
				const meta = db.createObjectStore('meta');

				// Initializing with minimum required data
				return SyncThenable.all([
          meta.put([], 'changes'),	
          meta.put({snapshot: null, vault: null, when: null}, 'sync'),
          groups.put({name: 'Default Group'})
        ].map(thenify));
			}
		}).then(db => {
      config.db = db;
      return new Store(config)
    });
	}

class Store {
  constructor(db) {
    this.db = db;
  }

  findGroups() {
    return Promise.resolve(this.db.transaction('groups').objectStore('groups').getAll());
  }

  findSecrets(query) {
    return co(function*() {
      const match = (secret) => {
        if (query === undefined) return true;
      
        if (query.group !== undefined && secret.groupId !== query.group) {
          return false;
        }
      
        if (query.keyword !== undefined) {
          query.keyword = query.keyword.toLowerCase();
          if (secret.resource.toLowerCase().search(query.keyword) == -1
            && secret.principal.toLowerCase().search(query.keyword) == -1
            && secret.note.toLowerCase().search(query.keyword) == -1) {
            return false;
          }
        }
        return true;
      };
    
      const secrets = yield this.db.transaction('secrets').objectStore('secrets').getAll();
      return secrets.filter(match);
    });
  }
  
  saveSecret(newSecret) {
    return this.db.transaction('secrets', 'readwrite').objectStore('secrets').put(newSecret);
  }

  createSecret(secret) {
    this._transaction(['meta','secrets'], {mode: 'readwrite', strategy: 'new'});
    const stores = this._openStores(['meta','secrets'], 'readwrite');

    // Will be autogenerated by IDB
    delete secret.id;

    const thenable = thenify(stores.secrets.put(secret)).then(id => {
      secret.id = id;
    }).then(() => thenify(stores.meta.get('changes'))).then(changes => {
      changes.push({operator: 'insert', table: 'secrets', record: secret});
      return thenify(stores.meta.put(changes, 'changes'));
    });

    return Promise.resolve(thenable);
  }

  removeSecret(id) {
    const stores = this._openStores(['meta','secrets'], 'readwrite');
    const thenable = SyncThenable.all([
      thenify(stores.secrets.get(id)),
      thenify(stores.meta.get('changes'))
    ]).then(([secret,changes]) => {
      if(secret === null) throw new Error(`Attempting to remove a non-existing secret with ID ${id}`);
      changes.push({operator: 'delete', table: 'secrets', record: secret});
      return thenify(stores.meta.put(changes, 'changes'));
    }).then(()=>thenify(stores.secrets.delete(id)));

    return Promise.resolve(thenable);
  }

  getSecret(id) {
    this._transaction(['secrets'],{strategy: 'new'});
    return Promise.resolve(this._storeGetByKey('secrets', id));
  }

  getGroup(id) {
    this._transaction(['groups'],{strategy: 'new'});
    return this._storeGetByKey('groups', id);
  }

  _request(method, path, params, body) {
    path = params === undefined ? path :
      path+'?'+Object.keys(params).map(key=>key+'='+encodeURIComponent(params[key])).join('&');
    const payload = (resolve, reject) => {
      var xhr = new XMLHttpRequest();
      xhr.open(method, this.config.endpoint + path);
      xhr.responseType = "json";
      xhr.onload = () => {
        if(xhr.status === 200) {
          resolve(xhr.response);
        } else {
          reject(new Error(xhr.statusText));
        }
      };
      xhr.onerror = () => reject(new Error("Network error"));
      xhr.send(JSON.stringify(body));
    };
    return new SyncThenable(payload);
  }

  _get(path, {params={}} = {}) {
    return this._request("GET", path, params);
  }

  _post(path, {params={}, body=undefined} = {}) {
    return this._request("POST", path, params, body);
  }

  _openStores(storeNames, mode) {
    const tx = this._transaction(storeNames, {mode: mode});
    return Object.assign.apply(null, storeNames.map(name => ({[name]: tx.objectStore(name)})));
  }

  _openStore(storeName, mode) {
    return this._openStores([storeName], mode)[storeName];
  }

  _clearStores(storeNames) {
    return SyncThenable.all(Object.values(this._openStores(storeNames)).map(store => {
      return thenify(store.clear());
    }));
  }

  _transaction(stores, {mode='readonly', strategy='require'}={}) {
    if(this._tx && strategy !== 'new') {
      if(!stores.every(store => this._tx.stores.includes(store))) {
        throw new Error(`Attempted transaction (scope: ${stores}), while a narrower scope (${this._tx.stores}) is active.`);
      }
      if(mode === 'readwrite' && this._tx.mode != 'readwrite') {
        throw new Error('Attempted overlapping transaction with a more restrictive mode');
      }
      return this._tx.tx;
    } else {
      const tx = this.config.db.transaction(stores, mode);
      tx.onabort = tx.onerror = (error) => {
        console.error('Transaction failed', error);
        this._tx = undefined
      };

      tx.oncomplete = () => {
        console.log('Transaction completed.');
        this._tx = undefined
      };

      this._tx = {tx: tx, stores: stores, mode: mode};
      return tx;
    }
  }

  findRemoteVaults() {
    return this._get('./meta');
  }

  getSyncStatus() {
    this._transaction(['meta'], {strategy: 'new'});
    return Promise.resolve(thenify(this._openStore('meta').get('sync'))).then(res =>  {
      const ret = res||{};
      ret.snapshot =  ret.snapshot||null;
      ret.vault =  ret.vault||null;
      return ret;
    });
  }

  sync() {
    this._transaction(['meta'], {mode: 'readonly', strategy: 'new'});
    return Promise.resolve(this._sync());
  }

  _sync() {
    return this._storeGetAll('meta').then(meta => {
        if(meta.sync === undefined) throw new Error('No vault to sync with!');
        const opts = {vaultId: meta.sync.vault.id};
        if(meta.sync.snapshot) {
          opts.sinceCommitId = meta.sync.snapshot.id;
        }

        return this._get(`./fetch`, {params: opts})
          .then(({vault: vault, snapshots: snapshots}) => ({vault: vault, snapshots: snapshots, meta: meta}));
      }).then(({vault: vault, meta: meta, snapshots: snapshots}) => {
        this._transaction(['secrets','groups','meta'], {mode: 'readwrite', strategy: 'new'});

        const stores = this._openStores(['secrets','groups','meta'], 'readwrite');
        const work = [];

        // Preparing a complete array of commands to apply against the local store
        const delta = snapshots.select('delta').map(JSON.parse).flatten();

        /// EXTRACTED

        // Updating sync status
        meta.sync = meta.sync||{}
        meta.sync.vault = vault;
        if(snapshots.length > 0) {
          meta.sync.snapshot = snapshots[snapshots.length-1];
        }
        meta.sync.when = (new Date()).toISOString();

        work.push(thenify(stores.meta.put(meta.sync,'sync')));
        work.push(thenify(stores.meta.put(meta.changes, 'changes')));

        return SyncThenable.all(work).then(()=>({meta: meta}));
      }).then(({meta: meta}) => {
        // If not dirty, pass context forward
        if(meta.changes.length === 0) {
          return {meta: meta};
        }

        // Otherwise, post changes and update the sync status
        return this._post('/save', {params: {vaultId: meta.sync.vault.id}, body: meta.changes}).then(snapshot => {
          meta.changes = [];
          meta.sync.snapshot = snapshot;
          meta.sync.when = (new Date()).toISOString();
          const store = this._openStore('meta', 'readwrite');
          return SyncThenable.all([
            store.put(meta.changes, 'changes'),
            store.put(meta.sync, 'sync')
          ].map(thenify));
        }).then(()=>({meta: meta}));
      }).then(({meta: meta}) => meta.sync);
  }

  setup(vaultId) {
    // Locking meta until this.sync reads it
    this._transaction(['meta','secrets','groups'],{mode: 'readwrite', strategy: 'new'});
    this._clear();

    const meta = this._openStore('meta', 'readwrite');

    return Promise.resolve(
      SyncThenable.all([
        meta.put({vault: {id: vaultId}}, 'sync'),
        meta.put([], 'changes')
      ].map(thenify))
        .then(()=>this._sync())
    );
  }

  isDirty() {
    return this._storeGetByKey('meta', 'changes').then(changes => changes.length > 0);
  }

  clear() {
    return thenify(window.indexedDB.deleteDatabase(this.config.idb_name)).then(() => {
      return load(this.config).then(store => this.config.db = store.config.db);
    });
  }

  _clear() {
    return this._clearStores(['meta','secrets','groups']);
  }

  getUnsyncedChanges() {
    return Promise.resolve(thenify(this._openStore('meta').get('changes')))
      .then(changes => changes === undefined ? [] : changes);
  }

  _storeGetByKey(store, key) {
    return thenify(this._transaction([store]).objectStore(store).get(key));
  }

  _storeGetAll(storeName) {
    const st = SyncThenable();

    const result = {};
    const request = this._transaction([storeName]).objectStore(storeName).openCursor();
    request.onerror = () => st.reject(request.error);
    request.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
          result[cursor.key] = cursor.value;
          cursor.continue();
      } else {
          st.resolve(result);
      }
    };

    return st;
  }
}

function thenify(request) {
  const ret = SyncThenable();
  request.onsuccess = () => ret.resolve(request.result);
  request.onerror = () => ret.reject(request.error);
  return ret;
}
