// Copyright 2016-2017 Danylo Vashchilenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { SyncThenable } from './sync-thenable.js';

export class Store {
  constructor(config) {
    this.config = config;
  }

  findGroups() {
    this._transaction(['groups'],{strategy: 'new'});
    return Promise.resolve(this._storeGetAll('groups').then(Object.values));
  }

  findSecrets(query) {
    const match = (secret) => {
      if(query === undefined) return true;

      if(query.group !== undefined && secret.groupId !== query.group) {
        return false;
      }

      if(query.keyword !== undefined) {
        query.keyword = query.keyword.toLowerCase();
        if(secret.resource.toLowerCase().search(query.keyword)==-1
          && secret.principal.toLowerCase().search(query.keyword)==-1
          && secret.note.toLowerCase().search(query.keyword)==-1) {
            return false;
          }
      }
      return true;
    };

    this._transaction(['secrets'],{strategy: 'new'});

    return Promise.resolve(
      this._storeGetAll('secrets')
        .then(secrets => Object.values(secrets).filter(match))
    );
  }

  saveSecret(newSecret) {
    this._transaction(['meta','secrets'], {mode: 'readwrite', strategy: 'new'});
    const stores = this._openStores(['meta','secrets'], 'readwrite');

    const thenable = SyncThenable.all([
      thenify(stores.secrets.get(newSecret.id)),
      thenify(stores.meta.get('changes'))
    ]).then(([oldSecret,changes]) => {
      if(oldSecret === undefined) throw new Error(`Attempting to update a non-existing secret with ID ${newSecret.id}`);
      changes.push({operator: 'update', table: 'secrets', record: newSecret});
      return thenify(stores.meta.put(changes, 'changes'));
    }).then(()=>thenify(stores.secrets.put(newSecret)));

    return Promise.resolve(thenable);
  }

  createSecret(secret) {
    this._transaction(['meta','secrets'], {mode: 'readwrite', strategy: 'new'});
    const stores = this._openStores(['meta','secrets'], 'readwrite');

    // Will be autogenerated by IDB
    delete secret.id;

    const thenable = thenify(stores.secrets.put(secret)).then(id => {
      secret.id = id;
    }).then(() => thenify(stores.meta.get('changes'))).then(changes => {
      changes.push({operator: 'insert', table: 'secrets', record: secret});
      return thenify(stores.meta.put(changes, 'changes'));
    });

    return Promise.resolve(thenable);
  }

  removeSecret(id) {
    const stores = this._openStores(['meta','secrets'], 'readwrite');
    const thenable = SyncThenable.all([
      thenify(stores.secrets.get(id)),
      thenify(stores.meta.get('changes'))
    ]).then(([secret,changes]) => {
      if(secret === null) throw new Error(`Attempting to remove a non-existing secret with ID ${id}`);
      changes.push({operator: 'delete', table: 'secrets', record: secret});
      return thenify(stores.meta.put(changes, 'changes'));
    }).then(()=>thenify(stores.secrets.delete(id)));

    return Promise.resolve(thenable);
  }

  getSecret(id) {
    this._transaction(['secrets'],{strategy: 'new'});
    return Promise.resolve(this._storeGetByKey('secrets', id));
  }

  getGroup(id) {
    this._transaction(['groups'],{strategy: 'new'});
    return this._storeGetByKey('groups', id);
  }

  _request(method, path, params, body) {
    path = params === undefined ? path :
      path+'?'+Object.keys(params).map(key=>key+'='+encodeURIComponent(params[key])).join('&');
    const payload = (resolve, reject) => {
      var xhr = new XMLHttpRequest();
      xhr.open(method, this.config.endpoint + path);
      xhr.responseType = "json";
      xhr.onload = () => {
        if(xhr.status === 200) {
          resolve(xhr.response);
        } else {
          reject(new Error(xhr.statusText));
        }
      };
      xhr.onerror = () => reject(new Error("Network error"));
      xhr.send(JSON.stringify(body));
    };
    return new SyncThenable(payload);
  }

  _get(path, {params={}} = {}) {
    return this._request("GET", path, params);
  }

  _post(path, {params={}, body=undefined} = {}) {
    return this._request("POST", path, params, body);
  }

  _openStores(storeNames, mode) {
    const tx = this._transaction(storeNames, {mode: mode});
    return Object.assign.apply(null, storeNames.map(name => ({[name]: tx.objectStore(name)})));
  }

  _openStore(storeName, mode) {
    return this._openStores([storeName], mode)[storeName];
  }

  _clearStores(storeNames) {
    return SyncThenable.all(Object.values(this._openStores(storeNames)).map(store => {
      return thenify(store.clear());
    }));
  }

  _transaction(stores, {mode='readonly', strategy='require'}={}) {
    if(this._tx && strategy !== 'new') {
      if(!stores.every(store => this._tx.stores.includes(store))) {
        throw new Error(`Attempted transaction (scope: ${stores}), while a narrower scope (${this._tx.stores}) is active.`);
      }
      if(mode === 'readwrite' && this._tx.mode != 'readwrite') {
        throw new Error('Attempted overlapping transaction with a more restrictive mode');
      }
      return this._tx.tx;
    } else {
      const tx = this.config.db.transaction(stores, mode);
      tx.onabort = tx.onerror = (error) => {
        console.error('Transaction failed', error);
        this._tx = undefined
      };

      tx.oncomplete = () => {
        console.log('Transaction completed.');
        this._tx = undefined
      };

      this._tx = {tx: tx, stores: stores, mode: mode};
      return tx;
    }
  }

  findRemoteVaults() {
    return this._get('./meta');
  }

  getSyncStatus() {
    this._transaction(['meta'], {strategy: 'new'});
    return Promise.resolve(thenify(this._openStore('meta').get('sync'))).then(res =>  {
      const ret = res||{};
      ret.snapshot =  ret.snapshot||null;
      ret.vault =  ret.vault||null;
      return ret;
    });
  }

  sync() {
    this._transaction(['meta'], {mode: 'readonly', strategy: 'new'});
    return Promise.resolve(this._sync());
  }

  _sync() {
    return this._storeGetAll('meta').then(meta => {
        if(meta.sync === undefined) throw new Error('No vault to sync with!');
        const opts = {vaultId: meta.sync.vault.id};
        if(meta.sync.snapshot) {
          opts.sinceCommitId = meta.sync.snapshot.id;
        }

        return this._get(`./fetch`, {params: opts})
          .then(({vault: vault, snapshots: snapshots}) => ({vault: vault, snapshots: snapshots, meta: meta}));
      }).then(({vault: vault, meta: meta, snapshots: snapshots}) => {
        this._transaction(['secrets','groups','meta'], {mode: 'readwrite', strategy: 'new'});

        const stores = this._openStores(['secrets','groups','meta'], 'readwrite');
        const work = [];

        // Preparing a complete array of commands to apply against the local store
        const delta = snapshots.select('delta').map(JSON.parse).flatten();

        // Searching for the highest new IDs in each table
        // to rebase the unsynced local IDs on top of it
        const maxIds = delta
          .filter(o => o.operator === 'insert')
          .groupBy('table')
          .mapValues(Array.selector('record'))
          .mapValues(Array.selector('id'))
          .mapValues(Array.aggregator(Math.max));

        meta.changes = meta.changes||[];

        for(const table of Object.keys(maxIds)) {
          if(maxIds[table] === -Infinity) continue;

          let nextKey = maxIds[table]+1;
          const rebase = {};

          for(const command of meta.changes) {
            if(command.operator === 'insert') {
              // Saving the mapping to adjust the local changes and the IDB
              rebase[command.record.id] = nextKey;
              command.record.id = nextKey;
              nextKey = nextKey+1;
            } else if(command.operator === 'update') {
              if(rebase.hasOwnProperty(command.record.id)) {
                command.record.id = rebase[command.record.id];
              }
            } else if(command.operator === 'delete') {
              if(rebase.hasOwnProperty(command.record.id)) {
                command.record.id = rebase[command.record.id];
                // Removing from the rebase, because this record's ID
                // should not be in further changes or local store
                delete rebase[command.record.id];
              }
            } else {
              throw new Error(`Unknown operator in the local changes: ${command.operator}`);
            }
          }

          for(const oldKey of Object.keys(rebase)) {
            const thenable = thenify(stores[table].get(oldKey)).then(record => {
              record.id = rebase[oldKey];
              return SyncThenable.all([
                thenify(stores[table].add(record)),
                thenify(stores[table].delete(oldKey))
              ]);
            });
            work.push(thenable);
          }
        }

        // Preparing locally updated records to detect merge conflicts
        const updatedIds = meta.changes
          .filter(c => c.operator === 'update')
          .groupBy('table')
          .mapValues(Array.selector('id'));

        // Updating each store with corresponding changes in the shapshots
        work.push.apply(work, delta.map(command => {
          if(command.operator === 'insert') {
            return thenify(stores[command.table].add(command.record));
          } else if(command.operator === 'update') {
            if(command.table in updatedIds && updatedIds[command.table].includes(command.record.id)) {
              // TODO: throw information neccesary to let the user resolve this conflict
              throw new Error(`A merge conflict detected for ID ${command.record.id} in ${command.table}!`);
            }
            return thenify(stores[command.table].put(command.record));
          } else if(command.operator === 'delete') {
            // Removing unsynced changes (updates and deletes) to remotely deleted records
            meta.changes.remove(c => c.record.id === command.record.id);
            return thenify(stores[command.table].delete(command.record.id));
          } else {
            throw new Error(`An unknown operator in the remote delta's command: ${command.operator}`);
          }
        }));

        // Updating sync status
        meta.sync = meta.sync||{}
        meta.sync.vault = vault;
        if(snapshots.length > 0) {
          meta.sync.snapshot = snapshots[snapshots.length-1];
        }
        meta.sync.when = (new Date()).toISOString();

        work.push(thenify(stores.meta.put(meta.sync,'sync')));
        work.push(thenify(stores.meta.put(meta.changes, 'changes')));

        return SyncThenable.all(work).then(()=>({meta: meta}));
      }).then(({meta: meta}) => {
        // If not dirty, pass context forward
        if(meta.changes.length === 0) {
          return {meta: meta};
        }

        // Otherwise, post changes and update the sync status
        return this._post('/save', {params: {vaultId: meta.sync.vault.id}, body: meta.changes}).then(snapshot => {
          meta.changes = [];
          meta.sync.snapshot = snapshot;
          meta.sync.when = (new Date()).toISOString();
          const store = this._openStore('meta', 'readwrite');
          return SyncThenable.all([
            store.put(meta.changes, 'changes'),
            store.put(meta.sync, 'sync')
          ].map(thenify));
        }).then(()=>({meta: meta}));
      }).then(({meta: meta}) => meta.sync);
  }

  setup(vaultId) {
    // Locking meta until this.sync reads it
    this._transaction(['meta','secrets','groups'],{mode: 'readwrite', strategy: 'new'});
    this._clear();

    const meta = this._openStore('meta', 'readwrite');

    return Promise.resolve(
      SyncThenable.all([
        meta.put({vault: {id: vaultId}}, 'sync'),
        meta.put([], 'changes')
      ].map(thenify))
        .then(()=>this._sync())
    );
  }

  isDirty() {
    return this._storeGetByKey('meta', 'changes').then(changes => changes.length > 0);
  }

  clear() {
    this._transaction(['meta','secrets','groups'], {mode: 'readwrite', strategy: 'new'});
    return this._clear();
  }

  _clear() {
    return this._clearStores(['meta','secrets','groups']);
  }

  getUnsyncedChanges() {
    return Promise.resolve(thenify(this._openStore('meta').get('changes')))
      .then(changes => changes === undefined ? [] : changes);
  }

  _storeGetByKey(store, key) {
    return thenify(this._transaction([store]).objectStore(store).get(key));
  }

  _storeGetAll(storeName) {
    const st = SyncThenable();

    const result = {};
    const request = this._transaction([storeName]).objectStore(storeName).openCursor();
    request.onerror = () => st.reject(request.error);
    request.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor) {
          result[cursor.key] = cursor.value;
          cursor.continue();
      } else {
          st.resolve(result);
      }
    };

    return st;
  }
}

function thenify(request) {
  const ret = SyncThenable();
  request.onsuccess = () => ret.resolve(request.result);
  request.onerror = () => ret.reject(request.error);
  return ret;
}
